# Week 1

## Introduction to Data Structures

### Definitions

**Data Structure**
A **data structure** is a way to store and organize data in order to facilitate access and modifications. No single data structure works well for all purposes, and so it is important to know the strengths and limitations of several of them.

**Algorithm**
Informally, an **algorithm** is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output. An algorithm is thus a sequence of computational steps that transform the input into the output. We can also view an algorithm as a tool for solving a well-specified computational problem,.

### Explanation

**Importance of Data Structures**
Data structures are the building blocks of efficient algorithms. If computers were infinitely fast and memory was free, any correct method for solving a problem would suffice. However, computing time and memory are bounded resources. You should use these resources wisely, and algorithms that are efficient in terms of time or space will help you do so.

Total system performance depends on choosing efficient algorithms and data structures as much as on choosing fast hardware. Just as rapid advances are being made in other computer technologies, they are being made in algorithms as well. Having a solid base of algorithmic knowledge and technique is one characteristic that separates the truly skilled programmers from the novices.

**Real World Applications**
Data structures and algorithms are at the core of most technologies used in contemporary computers. Practical applications are ubiquitous and include:

1.  **The Human Genome Project**: Requires sophisticated algorithms to identify genes and determine DNA sequences, enabling scientists to accomplish tasks efficiently.
2.  **The Internet**: Relies on clever algorithms to manage and manipulate large volumes of data, such as finding good routes for data travel and using search engines to find pages.
3.  **Electronic Commerce**: Depends on public-key cryptography and digital signatures, which are based on numerical algorithms and number theory.
4.  **Manufacturing and Commercial Enterprises**: Use algorithms to allocate scarce resources beneficially, such as placing oil wells, scheduling flight crews, or determining where to place additional resources for an Internet service provider.

### Solved Examples (from the book)

The following examples illustrate how computational problems are formulated, which is the first step in applying data structures and algorithms.

**Example 1: The Sorting Problem**
**Problem**: We need to sort a sequence of numbers into nondecreasing order. This problem arises frequently in practice and provides fertile ground for introducing many standard design techniques.
**Input**: A sequence of $n$ numbers $\langle a_1, a_2, \dots, a_n \rangle$.
**Output**: A permutation (reordering) $\langle a'_1, a'_2, \dots, a'_n \rangle$ of the input sequence such that $a'_1 \leq a'_2 \leq \dots \leq a'_n$.
**Instance**: Given the input sequence $\langle 31, 41, 59, 26, 41, 58 \rangle$, a sorting algorithm returns as output the sequence $\langle 26, 31, 41, 41, 58, 59 \rangle$.

**Example 2: The Shortest-Path Problem**
**Problem**: We are given a road map on which the distance between each pair of adjacent intersections is marked, and we wish to determine the shortest route from one intersection to another. The number of possible routes can be huge, even if we disallow routes that cross over themselves.
**Application**: A transportation firm, such as a trucking or railroad company, has a financial interest in finding shortest paths through a road or rail network because taking shorter paths results in lower labor and fuel costs. Or a routing node on the Internet may need to find the shortest path through the network in order to route a message quickly.

**Example 3: Longest Common Subsequence**
**Problem**: We are given two ordered sequences of symbols, $X = \langle x_1, x_2, \dots, x_m \rangle$ and $Y = \langle y_1, y_2, \dots, y_n \rangle$, and we wish to find a longest common subsequence of $X$ and $Y$.
**Definition**: A subsequence of $X$ is just $X$ with some (or possibly all or none) of its elements removed.
**Instance**: For example, one subsequence of $\langle A, B, C, D, E, F, G \rangle$ would be $\langle B, C, E, G \rangle$.
**Application**: This gives a measure of how similar two sequences are, useful for comparing DNA strands.

**Example 4: Topological Sort**
**Problem**: We are given a mechanical design in terms of a library of parts, where each part may include instances of other parts, and we need to list the parts in order so that each part appears before any part that uses it.
**Complexity**: If the design comprises $n$ parts, then there are $n!$ possible orders. Because the factorial function grows faster than even an exponential function, we cannot feasibly generate each possible order and then verify it.
**Solution**: This problem is an instance of topological sorting, which can be solved efficiently using specific graph algorithms.

**Example 5: Convex Hull**
**Problem**: We are given $n$ points in the plane, and we wish to find the convex hull of these points.
**Definition**: The convex hull is the smallest convex polygon containing the points. Intuitively, we can think of each point as being represented by a nail sticking out from a board. The convex hull would be represented by a tight rubber band that surrounds all the nails.
**Application**: This problem has many choices for the vertices of the convex hull, and efficient methods exist to find it.

### Solved Exercise Questions (from the book)

**Question 1**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.1-1
**Prompt**: Give a real-world example that requires sorting or a real-world example that requires computing a convex hull.
**Solution**:
*   **Sorting**: Organizing a library's book catalog by title or author, displaying a list of files in a directory by size or date, or arranging exam scores to determine grade cutoffs.
*   **Convex Hull**: Determining the outer boundary of a set of physical obstacles for robot navigation, or finding the smallest enclosure needed for a set of points in computer graphics.

**Question 2**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.1-2
**Prompt**: Other than speed, what other measures of efficiency might one use in a real-world setting?
**Solution**:
Other measures of efficiency include:
*   **Memory usage**: The amount of RAM or storage required by the algorithm.
*   **Bandwidth**: The amount of data transmitted over a network.
*   **Hardware requirements**: Whether the algorithm requires specialized hardware (like a GPU) or runs on standard CPUs.
*   **Implementation cost**: The ease of coding and maintaining the algorithm.

**Question 3**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.1-3
**Prompt**: Select a data structure that you have seen previously, and discuss its strengths and limitations.
**Solution**:
*   **Linked List**:
    *   *Strengths*: Dynamic size (can grow/shrink at runtime), efficient insertion/deletion at the beginning or end (O(1)).
    *   *Limitations*: Sequential access (slow lookup O(n)), extra memory for pointers.
*   **Array**:
    *   *Strengths*: Random access (fast lookup O(1)), memory efficient (no pointers).
    *   *Limitations*: Fixed size (usually), expensive insertion/deletion in the middle (requires shifting elements).

**Question 4**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.1-4
**Prompt**: How are the shortest-path and traveling-salesman problems given above similar? How are they different?
**Solution**:
*   **Similarity**: Both involve finding paths in a graph (road map) that minimize a total cost (distance). Both are optimization problems.
*   **Difference**: The shortest-path problem finds the most efficient route between two specific points and can be solved efficiently (polynomial time). The traveling-salesman problem requires visiting *every* point in a set exactly once and returning to the start; it is NP-complete, meaning no efficient algorithm is known for the general case.

**Question 5**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.1-5
**Prompt**: Come up with a real-world problem in which only the best solution will do. Then come up with one in which a solution that is “approximately” the best is good enough.
**Solution**:
*   **Best solution required**: Balancing a bank ledger or calculating a payroll. A single cent error is unacceptable.
*   **Approximate solution acceptable**: Determining the optimal route for a delivery truck to visit 50 locations (Traveling Salesman Problem). Finding the absolute optimal path might take centuries; a route that is within 1% of optimal found in a few minutes is much more valuable.

**Question 6**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.2-1
**Prompt**: Give an example of an application that requires algorithmic content at the application level, and discuss the function of the algorithms involved.
**Solution**:
*   **Application**: A GPS navigation system (e.g., Google Maps).
*   **Function**: It relies on algorithms to calculate the shortest or fastest path (Dijkstra's or A*), render map graphics (computational geometry), and interpolate addresses. It handles massive graphs where efficiency is critical for user experience.

**Question 7**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.2-2
**Prompt**: Suppose we are comparing implementations of insertion sort and merge sort on the same machine. For inputs of size $n$, insertion sort runs in $8n^2$ steps, while merge sort runs in $64n \lg n$ steps. For which values of $n$ does insertion sort beat merge sort?
**Solution**:
We want to find $n$ such that $8n^2 < 64n \lg n$.
Dividing by $8n$ (assuming $n > 0$): $n < 8 \lg n$.
Let's test values:
*   If $n=2$: $2 < 8(1) = 8$ (True)
*   If $n=4$: $4 < 8(2) = 16$ (True)
*   If $n=8$: $8 < 8(3) = 24$ (True)
*   If $n=32$: $32 < 8(5) = 40$ (True)
*   If $n=43$: $43 < 8(5.42) \approx 43.4$ (True)
*   If $n=44$: $44 < 8(5.45) \approx 43.6$ (False)
Insertion sort beats merge sort for $n$ approximately between 2 and 43.

**Question 8**
**Source**: *Cormen Introduction to Algorithms*, Exercise 1.2-3
**Prompt**: What is the smallest value of $n$ such that an algorithm whose running time is $100n^2$ runs faster than an algorithm whose running time is $2^n$ on the same machine?
**Solution**:
We want to find the smallest integer $n$ such that $100n^2 < 2^n$.
*   If $n=10$: $100(100) = 10,000$ vs $2^{10} = 1,024$ (False)
*   If $n=14$: $100(196) = 19,600$ vs $2^{14} = 16,384$ (False)
*   If $n=15$: $100(225) = 22,500$ vs $2^{15} = 32,768$ (True)
The smallest value is $n = 15$.

**Question 9**
**Source**: *Python for Everybody*, Exercise 1
**Prompt**: What is the function of the secondary memory in a computer?
*   **a.** Execute all of the computation and logic of the program
*   **b.** Retrieve web pages over the Internet
*   **c.** Store information for the long term, even beyond a power cycle
*   **d.** Take input from the user
**Solution**:
**c. Store information for the long term, even beyond a power cycle.**
Secondary memory (like disk drives or flash memory) retains information even when power is turned off, unlike main memory.

**Question 10**
**Source**: *Python for Everybody*, Exercise 2
**Prompt**: What is a program?
**Solution**:
A **program** is a set of stored instructions that specifies a computation. It is the sequence of instructions written by a programmer to answer the CPU's question "What next?",.
