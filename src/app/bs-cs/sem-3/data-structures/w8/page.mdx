# Week 8

## Sorting Algorithms: Selection, Insertion, Merge, Quick

### Definitions

**Sorting Problem**
Input: A sequence of $n$ numbers $\langle a_1, a_2, \dots, a_n \rangle$.
Output: A permutation (reordering) $\langle a'_1, a'_2, \dots, a'_n \rangle$ of the input sequence such that $a'_1 \leq a'_2 \leq \dots \leq a'_n$.

**Insertion Sort**
An efficient algorithm for sorting a small number of elements. It works the way many people sort a hand of playing cards. We start with an empty left hand and the cards face down on the table. We then remove one card at a time from the table and insert it into the correct position in the left hand. To find the correct position for a card, we compare it with each of the cards already in the hand, from right to left.

**Selection Sort**
An algorithm that sorts an array by repeatedly finding the smallest element (or largest, depending on the sorting order) from the unsorted segment of the array and swapping it with the first unsorted element. It moves the boundary of the sorted segment one element to the right in each iteration.

**Merge Sort**
A recursive algorithm that follows the **divide-and-conquer** paradigm. It operates as follows:
1.  **Divide**: Divide the $n$-element sequence to be sorted into two subsequences of $n/2$ elements each.
2.  **Conquer**: Sort the two subsequences recursively using merge sort.
3.  **Combine**: Merge the two sorted subsequences to produce the sorted answer.

**Quicksort**
A divide-and-conquer algorithm that sorts "in place." It operates as follows:
1.  **Divide**: Partition the array $A[p \dots r]$ into two (possibly empty) subarrays $A[p \dots q-1]$ and $A[q+1 \dots r]$ such that each element of $A[p \dots q-1]$ is less than or equal to $A[q]$, which is, in turn, less than or equal to each element of $A[q+1 \dots r]$. Compute the index $q$ as part of this partitioning procedure.
2.  **Conquer**: Sort the two subarrays recursively by calls to quicksort.
3.  **Combine**: Because the subarrays are already sorted, no work is needed to combine them: the entire array is now sorted.

### Explanation

**Comparison of Complexity**
*   **Insertion Sort**: Worst-case running time is $\Theta(n^2)$. It is efficient for small input sizes and is an in-place sort.
*   **Selection Sort**: Runs in $\Theta(n^2)$ time for all cases (best, average, and worst) because finding the minimum requires scanning the remaining elements every time.
*   **Merge Sort**: Worst-case running time is $\Theta(n \lg n)$. It requires auxiliary storage for the merging process, so it does not sort in place.
*   **Quicksort**: Worst-case running time is $\Theta(n^2)$, but its expected running time is $\Theta(n \lg n)$ with very small constant factors. It sorts in place and is often the practical choice for sorting large arrays.

**The Role of Partitioning (Quicksort)**
The key to the algorithm is the `PARTITION` procedure, which rearranges the subarray $A[p \dots r]$ in place. It selects an element $x = A[r]$ as a **pivot** element. It moves elements smaller than $x$ to the left and elements larger than $x$ to the right, placing the pivot between them.

**The Role of Merging (Merge Sort)**
The key operation is the merging of two sorted sequences in the "combine" step. We merge by calling an auxiliary procedure `MERGE(A, p, q, r)`, where $A$ is an array and $p, q, r$ are indices such that $p \le q < r$. The procedure assumes that the subarrays $A[p \dots q]$ and $A[q+1 \dots r]$ are in sorted order. It merges them to form a single sorted subarray that replaces the current subarray $A[p \dots r]$.

### Solved Examples (from the book)

**Example 1: Insertion Sort Execution**
**Context**: Sort the array $A = \langle 5, 2, 4, 6, 1, 3 \rangle$ using Insertion Sort.
**Trace**:
1.  **Start**: $A =$. Key = 2. Compare 2 with 5. Shift 5. Insert 2.
    Result: $\langle 2, 5, 4, 6, 1, 3 \rangle$.
2.  **Next**: Key = 4. Compare with 5 (shift), compare with 2 (stop). Insert 4.
    Result: $\langle 2, 4, 5, 6, 1, 3 \rangle$.
3.  **Next**: Key = 6. Compare with 5 (stop). Insert 6.
    Result: $\langle 2, 4, 5, 6, 1, 3 \rangle$.
4.  **Next**: Key = 1. Compare 6, 5, 4, 2 (shift all). Insert 1.
    Result: $\langle 1, 2, 4, 5, 6, 3 \rangle$.
5.  **Next**: Key = 3. Compare 6, 5, 4 (shift). Compare 2 (stop). Insert 3.
    Result: $\langle 1, 2, 3, 4, 5, 6 \rangle$.

**Example 2: Merge Sort Operation**
**Context**: Sort the array $A = \langle 5, 2, 4, 7, 1, 3, 2, 6 \rangle$.
**Trace (Bottom-Up View)**:
1.  **Merge pairs of 1**: Merge $\langle 5 \rangle$ and $\langle 2 \rangle \to \langle 2, 5 \rangle$. Merge $\langle 4 \rangle$ and $\langle 7 \rangle \to \langle 4, 7 \rangle$. Merge $\langle 1 \rangle$ and $\langle 3 \rangle \to \langle 1, 3 \rangle$. Merge $\langle 2 \rangle$ and $\langle 6 \rangle \to \langle 2, 6 \rangle$.
    State: $\langle 2, 5, 4, 7, 1, 3, 2, 6 \rangle$.
2.  **Merge pairs of 2**: Merge $\langle 2, 5 \rangle$ and $\langle 4, 7 \rangle \to \langle 2, 4, 5, 7 \rangle$. Merge $\langle 1, 3 \rangle$ and $\langle 2, 6 \rangle \to \langle 1, 2, 3, 6 \rangle$.
    State: $\langle 2, 4, 5, 7, 1, 2, 3, 6 \rangle$.
3.  **Merge pairs of 4**: Merge $\langle 2, 4, 5, 7 \rangle$ and $\langle 1, 2, 3, 6 \rangle$.
    Compare heads: $1 < 2$ (take 1), $2 \le 2$ (take 2), $2 < 3$ (take 2), $3 < 4$ (take 3), $4 < 6$ (take 4), $5 < 6$ (take 5), $6 < 7$ (take 6), take 7.
    Final Result: $\langle 1, 2, 2, 3, 4, 5, 6, 7 \rangle$.

**Example 3: Partitioning in Quicksort**
**Context**: `PARTITION(A, p, r)` on array $A = \langle 2, 8, 7, 1, 3, 5, 6, 4 \rangle$. Pivot $x = 4$ ($A[r]$).
**Trace**:
*   $i$ starts at $p-1$. $j$ scans from $p$ to $r-1$.
*   $j=1$ ($val=2$): $2 \le 4$. Increment $i$. Swap $A[i], A[j]$. Array: $\langle 2, 8, 7, 1, 3, 5, 6, 4 \rangle$.
*   $j=2$ ($val=8$): $8 > 4$. No swap.
*   $j=3$ ($val=7$): $7 > 4$. No swap.
*   $j=4$ ($val=1$): $1 \le 4$. Increment $i$. Swap $A[i]$ (was 8) and $A[j]$ (1). Array: $\langle 2, 1, 7, 8, 3, 5, 6, 4 \rangle$.
*   $j=5$ ($val=3$): $3 \le 4$. Increment $i$. Swap $A[i]$ (was 7) and $A[j]$ (3). Array: $\langle 2, 1, 3, 8, 7, 5, 6, 4 \rangle$.
*   Loop ends. Swap pivot $A[r]$ with $A[i+1]$ (was 8).
*   **Result**: Array $\langle 2, 1, 3, 4, 7, 5, 6, 8 \rangle$. Pivot 4 is now at index 4. Returns index 4.

**Example 4: Quicksort Worst-Case Analysis**
**Problem**: Analyze the worst-case behavior of Quicksort.
**Analysis**:
The worst case occurs when the partitioning produces one subproblem with $n-1$ elements and one with 0 elements. This happens if the input is already sorted or reverse sorted.
The recurrence is:
$$
T(n) = T(n-1) + T(0) + \Theta(n) = T(n-1) + \Theta(n)
$$
Using the substitution method, the solution is $T(n) = \Theta(n^2)$.
This demonstrates that if the partitioning is maximally unbalanced at every recursive level, the running time is quadratic.

**Example 5: Merge Sort Analysis (Recurrence Tree)**
**Problem**: Solve the recurrence $T(n) = 2T(n/2) + cn$ where $c$ is a constant.
**Analysis**:
1.  The top level has cost $cn$.
2.  The next level has 2 subproblems of size $n/2$. Cost: $2 \times c(n/2) = cn$.
3.  The next level has 4 subproblems of size $n/4$. Cost: $4 \times c(n/4) = cn$.
4.  The tree has $\lg n + 1$ levels.
5.  Each level contributes $cn$.
6.  Total cost $\approx cn \lg n$. Thus $T(n) = \Theta(n \lg n)$.

### Solved Exercise Questions (from the book)

**Question 1**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.1-1
**Prompt**: Using Figure 2.2 as a model, illustrate the operation of `INSERTION-SORT` on the array $A = \langle 31, 41, 59, 26, 41, 58 \rangle$.

**Solution**:
*   Initial: $\langle 31, 41, 59, 26, 41, 58 \rangle$
*   $j=2$, key=41: $41 > 31$, no shift. Array: $\langle 31, 41, 59, 26, 41, 58 \rangle$
*   $j=3$, key=59: $59 > 41$, no shift. Array: $\langle 31, 41, 59, 26, 41, 58 \rangle$
*   $j=4$, key=26: $26 < 59$ (shift), $26 < 41$ (shift), $26 < 31$ (shift). Insert 26.
    Array: $\langle 26, 31, 41, 59, 41, 58 \rangle$
*   $j=5$, key=41: $41 < 59$ (shift), $41 = 41$ (stop). Insert 41.
    Array: $\langle 26, 31, 41, 41, 59, 58 \rangle$
*   $j=6$, key=58: $58 < 59$ (shift), $58 > 41$ (stop). Insert 58.
    Array: $\langle 26, 31, 41, 41, 58, 59 \rangle$

**Question 2**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.1-2
**Prompt**: Rewrite the `INSERTION-SORT` procedure to sort into nonincreasing instead of nondecreasing order.

**Solution**:
Change the comparison in the while loop from $A[i] > key$ to $A[i] < key$.
```text
INSERTION-SORT-DESCENDING(A)
1 for j = 2 to A.length
2     key = A[j]
3     i = j - 1
4     while i > 0 and A[i] < key
5         A[i + 1] = A[i]
6         i = i - 1
7     A[i + 1] = key
```

**Question 3**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.2-2
**Prompt**: Write pseudocode for **selection sort**. What loop invariant does this algorithm maintain? Why does it need to run for only the first $n-1$ elements?

**Solution**:
```text
SELECTION-SORT(A)
1 n = A.length
2 for j = 1 to n - 1
3     smallest = j
4     for i = j + 1 to n
5         if A[i] < A[smallest]
6             smallest = i
7     exchange A[j] with A[smallest]
```
*Loop Invariant*: At the start of each iteration of the outer loop (indexed by $j$), the subarray $A[1 \dots j-1]$ contains the $j-1$ smallest elements of the array in sorted order.
*Running Time*: It runs for $n-1$ elements because if the first $n-1$ elements are the smallest and in sorted order, the single remaining element must be the largest and is already in its correct position.

**Question 4**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.3-1
**Prompt**: Illustrate the operation of merge sort on the array $A = \langle 3, 41, 52, 26, 38, 57, 9, 49 \rangle$.

**Solution**:
1.  Divide into singletons: $\langle 3 \rangle, \langle 41 \rangle, \langle 52 \rangle, \langle 26 \rangle, \langle 38 \rangle, \langle 57 \rangle, \langle 9 \rangle, \langle 49 \rangle$.
2.  Merge to size 2:
    $\langle 3, 41 \rangle$, $\langle 26, 52 \rangle$, $\langle 38, 57 \rangle$, $\langle 9, 49 \rangle$.
3.  Merge to size 4:
    Merge $\langle 3, 41 \rangle$ and $\langle 26, 52 \rangle \to \langle 3, 26, 41, 52 \rangle$.
    Merge $\langle 38, 57 \rangle$ and $\langle 9, 49 \rangle \to \langle 9, 38, 49, 57 \rangle$.
4.  Merge to size 8:
    Merge $\langle 3, 26, 41, 52 \rangle$ and $\langle 9, 38, 49, 57 \rangle$.
    Result: $\langle 3, 9, 26, 38, 41, 49, 52, 57 \rangle$.

**Question 5**
**Source**: *Cormen Introduction to Algorithms*, Exercise 7.1-1
**Prompt**: Illustrate the operation of `PARTITION` on the array $A = \langle 13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11 \rangle$.

**Solution**: Pivot is $11$ ($A$).
*   Swap 9 with 13 (index 1).
*   Swap 5 with 19 (index 2).
*   Swap 8 with 12 (index 4 - Note: 12 was at index 5 before swap? *Trace carefully:*)
    *   $i=0, j=1$. $13 > 11$.
    *   $j=2$. $19 > 11$.
    *   $j=3$. $9 \le 11$. $i=1$. Swap 9, 13. Array: $[9, 19, 13, 5 \dots]$
    *   $j=4$. $5 \le 11$. $i=2$. Swap 5, 19. Array: $[9, 5, 13, 19 \dots]$
    *   $j=5$. $12 > 11$.
    *   $j=6$. $8 \le 11$. $i=3$. Swap 8, 13. Array: $[9, 5, 8, 19, 12 \dots]$
    *   $j=7$. $7 \le 11$. $i=4$. Swap 7, 19. Array: $[9, 5, 8, 7, 12, 13 \dots]$
    *   $j=8$. $4 \le 11$. $i=5$. Swap 4, 12. Array: $[9, 5, 8, 7, 4, 13 \dots]$
    *   $j=9$. $21 > 11$.
    *   $j=10$. $2 \le 11$. $i=6$. Swap 2, 13. Array: $\langle 9, 5, 8, 7, 4, 2, 19, 12, 21, 13, 6, 11 \rangle$.
    *   $j=11$. $6 \le 11$. $i=7$. Swap 6, 21. Array: $\langle 9, 5, 8, 7, 4, 2, 6, 12, 21, 13, 19, 11 \rangle$.
*   Final Swap: Pivot 11 with $A[i+1]$ (19).
*   **Result**: $\langle 9, 5, 8, 7, 4, 2, 6, 11, 12, 13, 19, 21 \rangle$.

**Question 6**
**Source**: *Cormen Introduction to Algorithms*, Exercise 7.1-2
**Prompt**: What value of $q$ does `PARTITION` return when all elements in the array $A[p \dots r]$ have the same value?

**Solution**:
Since the condition in `PARTITION` is $A[j] \le x$ (where $x$ is the pivot), every element will trigger a swap. The variable $i$ will increment for every element from $p$ to $r-1$.
Finally, the pivot is swapped with $A[i+1]$.
Thus, it returns $q = r$. The partition is maximally unbalanced ($n-1$ elements in the low partition, 0 in the high partition).

**Question 7**
**Source**: *Cormen Introduction to Algorithms*, Exercise 7.2-2
**Prompt**: What is the running time of `QUICKSORT` when all elements of array $A$ have the same value?

**Solution**:
As shown in Question 6, `PARTITION` returns $r$ (unbalanced split) when elements are equal.
The recurrence becomes $T(n) = T(n-1) + T(0) + \Theta(n)$.
This solves to $\Theta(n^2)$.

**Question 8**
**Source**: *Cormen Introduction to Algorithms*, Exercise 7.2-3
**Prompt**: Show that the running time of `QUICKSORT` is $\Theta(n^2)$ when the array $A$ contains distinct elements and is sorted in decreasing order.

**Solution**:
Pivot is $A[r]$. Since the array is decreasing, the pivot is the smallest element.
The loop compares every element $A[j]$ with the pivot. Since $A[j] > pivot$ for all $j < r$, no swaps occur inside the loop. The pivot is then swapped to index $p$ (the beginning).
The partition produces a subproblem of size 0 (left) and size $n-1$ (right).
Recurrence: $T(n) = T(n-1) + \Theta(n)$. Summing the costs: $\sum_{i=1}^n i = \Theta(n^2)$.

**Question 9**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.3-4
**Prompt**: Insertion sort can be expressed as a recursive procedure as follows. In order to sort $A[1 \dots n]$, we recursively sort $A[1 \dots n-1]$ and then insert $A[n]$ into the sorted array $A[1 \dots n-1]$. Write a recurrence for the worst-case running time of this recursive version of insertion sort.

**Solution**:
To sort $n$ elements:
1.  Recursively sort $n-1$ elements: Time $T(n-1)$.
2.  Insert $A[n]$ into sorted $A[1 \dots n-1]$. In the worst case, this takes $\Theta(n)$ time (shifting all elements).
Recurrence:
$$
T(n) = \begin{cases} \Theta(1) & \text{if } n = 1 \\ T(n-1) + \Theta(n) & \text{if } n > 1 \end{cases}
$$
The solution is $\Theta(n^2)$.

**Question 10**
**Source**: *Cormen Introduction to Algorithms*, Problem 2-1 (excerpt)
**Prompt**: Although merge sort runs in $\Theta(n \lg n)$ and insertion sort runs in $\Theta(n^2)$, the constant factors in insertion sort can make it faster in practice for small problem sizes. Consider a modification to merge sort in which $n/k$ sublists of length $k$ are sorted using insertion sort and then merged. Show that insertion sort can sort the $n/k$ sublists, each of length $k$, in $\Theta(nk)$ worst-case time.

**Solution**:
Sorting one sublist of length $k$ using insertion sort takes $\Theta(k^2)$ time.
We have $n/k$ such sublists.
Total time = (number of sublists) $\times$ (time per sublist)
Total time = $(n/k) \times \Theta(k^2) = \Theta(nk)$.
