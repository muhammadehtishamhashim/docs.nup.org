# Week 4

## Searching an Unsorted Array, Binary Search, Operations

### Definitions

**Linear Search**
A search algorithm that checks each element of a collection (like an array or list) sequentially until a match is found or the collection is exhausted. It works on unsorted arrays.

**Binary Search**
A search algorithm for **sorted** arrays. It checks the midpoint of the sequence against the target value and eliminates half of the sequence from further consideration, repeating the process on the remaining half. It has a worst-case running time of $\Theta(\lg n)$.

**Operations on Arrays**
Common operations include insertion (adding an element), deletion (removing an element), and traversal. Insertion into a sorted array requires shifting elements to maintain order, taking linear time.

### Explanation

**Linear vs. Binary Search**
*   **Linear Search**:
    *   *Precondition*: None (array can be unsorted).
    *   *Complexity*: $O(n)$ worst-case and average-case.
    *   *Mechanism*: Scan $A[1 \dots n]$ index by index.
*   **Binary Search**:
    *   *Precondition*: Array must be sorted.
    *   *Complexity*: $O(\lg n)$ worst-case.
    *   *Mechanism*: Divide and conquer. Compare target with $A[mid]$. If target $< A[mid]$, recurse on left; else recurse on right.

**Array Operations**
In languages like Python, lists (arrays) are mutable. Elements can be changed, added (`append`), or removed (`pop`, `remove`). In low-level representations, arrays are fixed-size, and "deletion" might involve shifting all subsequent elements left, costing $O(n)$.

### Solved Examples (from the book)

**Example 1: Linear Search Pseudocode**
**Context**: Searching for value $\nu$ in array $A$.
**Code**:
```
LINEAR-SEARCH(A, v)
1 for i = 1 to A.length
2     if A[i] == v
3         return i
4 return NIL
```
**Correctness**: Uses a loop invariant. At start of iteration $i$, subarray $A[1..i-1]$ does not contain $\nu$.

**Example 2: Binary Search Logic**
**Context**: Searching for $\nu$ in sorted array $A$.
**Logic**:
1.  Check midpoint.
2.  If $A[mid] == \nu$, return $mid$.
3.  If $\nu < A[mid]$, search $A[low \dots mid-1]$.
4.  If $\nu > A[mid]$, search $A[mid+1 \dots high]$.
**Time**: $T(n) = T(n/2) + \Theta(1) \implies \Theta(\lg n)$.

**Example 3: Python List Methods**
**Context**: Modifying lists.
**Code**:
```python
t = ['a', 'b', 'c']
t.append('d')
print(t) # ['a', 'b', 'c', 'd']
t1 = ['a', 'b']
t2 = ['c', 'd']
t1.extend(t2)
print(t1) # ['a', 'b', 'c', 'd']
```
**Explanation**: `append` adds one element; `extend` appends a list of elements.

**Example 4: Python Deleting Elements**
**Context**: Different ways to remove items.
**Code**:
```python
t = ['a', 'b', 'c']
x = t.pop(1)   # Removes 'b' at index 1, returns 'b'
del t       # Removes 'c' (now at index 1)
t.remove('a')  # Removes element 'a' by value
```

**Example 5: Insertion Sort Analysis**
**Context**: Sorting an array $A$.
**Logic**: Efficient for small numbers of elements. It works like sorting a hand of playing cards.
**Complexity**: Best case $\Theta(n)$ (already sorted). Worst case $\Theta(n^2)$ (reverse sorted).
**Relevance**: Uses operations on arrays (shifting elements to make space for insertion).

### Solved Exercise Questions (from the book)

**Question 1**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.1-3
**Prompt**: Write pseudocode for linear search... Using a loop invariant, prove that your algorithm is correct.
**Solution**:
*   **Pseudocode**: See Solved Example 1 above.
*   **Loop Invariant**: At the start of each iteration of the loop, the subarray $A[1 \dots i-1]$ consists of elements that are different from $\nu$.
*   **Initialization**: Initially $i=1$, subarray is empty (trivially true).
*   **Maintenance**: If $A[i] \neq \nu$, then $A[1 \dots i]$ doesn't contain $\nu$, invariant holds for $i+1$.
*   **Termination**: Terminates if found (correct index returned) or loop finishes ($i > A.length$). If loop finishes, $\nu$ was not in $A$, returns NIL (correct).

**Question 2**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.1-4
**Prompt**: Consider the problem of adding two $n$-bit binary integers, stored in two $n$-element arrays $A$ and $B$. The sum should be stored in binary form in an $(n+1)$-element array $C$.
**Solution**:
```
ADD-BINARY(A, B)
1 carry = 0
2 for i = A.length downto 1
3     sum = A[i] + B[i] + carry
4     C[i+1] = sum % 2
5     carry = sum / 2  (integer division)
6 C = carry
7 return C
```

**Question 3**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.2-2
**Prompt**: Write pseudocode for **selection sort**.
**Solution**:
```
SELECTION-SORT(A)
1 n = A.length
2 for j = 1 to n - 1
3     smallest = j
4     for i = j + 1 to n
5         if A[i] < A[smallest]
6             smallest = i
7     exchange A[j] with A[smallest]
```
**Loop Invariant**: At the start of iteration $j$, $A[1 \dots j-1]$ contains the $j-1$ smallest elements in sorted order.

**Question 4**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.2-3
**Prompt**: Consider linear search. How many elements need to be checked on average? Worst case?
**Solution**:
*   **Average Case**: If the element is present and equally likely to be in any position, average checks = $(n+1)/2$. Thus $\Theta(n)$.
*   **Worst Case**: Element not present or at the end. Checks = $n$. Thus $\Theta(n)$.

**Question 5**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.3-5
**Prompt**: Write pseudocode for binary search.
**Solution**:
```
BINARY-SEARCH(A, v, low, high)
1 if high < low
2    return NIL
3 mid = floor((low + high) / 2)
4 if A[mid] == v
5    return mid
6 elseif v < A[mid]
7    return BINARY-SEARCH(A, v, low, mid - 1)
8 else return BINARY-SEARCH(A, v, mid + 1, high)
```
Worst-case running time is $\Theta(\lg n)$.

**Question 6**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.3-6
**Prompt**: Can we use binary search to improve insertion sort's worst-case running time to $\Theta(n \lg n)$?
**Solution**:
We can use binary search to *find* the position to insert the key in $O(\lg n)$ time. However, to *insert* the key, we still need to shift elements to the right. Shifting takes $O(n)$ time in the worst case. Therefore, the overall worst-case running time remains $\Theta(n^2)$.

**Question 7**
**Source**: *Cormen Introduction to Algorithms*, Exercise 2.3-7
**Prompt**: Describe a $\Theta(n \lg n)$ algorithm that... determines whether or not there exist two elements in set $S$ whose sum is exactly $x$.
**Solution**:
1.  Sort $S$ using Merge Sort ($\Theta(n \lg n)$).
2.  For each element $s_i$ in $S$:
    a. Calculate complement $y = x - s_i$.
    b. Use Binary Search to look for $y$ in $S$ ($\Theta(\lg n)$).
Total time: $O(n \lg n) + n \times O(\lg n) = O(n \lg n)$.

**Question 8**
**Source**: *Python for Everybody*, Chapter 8 Exercise 4
**Prompt**: Read file `romeo.txt`, split lines into words, check if word is in list. If not, append. Sort and print.
**Solution**:
```python
fname = input("Enter file: ")
fh = open(fname)
lst = list()
for line in fh:
    words = line.split()
    for word in words:
        if word not in lst:
            lst.append(word)
lst.sort()
print(lst)
```

**Question 9**
**Source**: *Python for Everybody*, Chapter 8 Exercise 5
**Prompt**: Read mail box data, count lines starting with "From ", print second word (email).
**Solution**:
```python
count = 0
# loop through file lines
    if line.startswith('From '):
        words = line.split()
        print(words)
        count += 1
print("There were", count, "lines in the file...")
```

**Question 10**
**Source**: *Python for Everybody*, Chapter 8 Exercise 6
**Prompt**: Rewrite the program that prompts the user for a list of numbers... print max and min.
**Solution**:
```python
nums = []
while True:
    val = input("Enter a number: ")
    if val == 'done': break
    try:
        fval = float(val)
        nums.append(fval)
    except:
        print("Invalid input")
print("Maximum:", max(nums))
print("Minimum:", min(nums))
```

